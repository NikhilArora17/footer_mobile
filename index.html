<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>B1B5C0 Smoke Footer â€” 400Ã—800 Mobile (Taller Smoke)</title>
<style>
  :root{
    /* Desktop/tablet size (unchanged) */
    --height: 720px;

    /* MOTION */
    --speed: 0.045;
    --swirl: 0.10;

    /* LOOK */
    --detail: 1.5;
    /* â†“ Lower soft = fades later (taller plume) */
    --soft: 1.0;      /* was 2.4 */
    --alpha: 0.96;    /* was 0.92; a bit stronger overall */

    /* COLOR */
    --colorA: #E6E8EE;
    --colorB: #B1B5C0;
  }

  html,body{ margin:0; height:100%; background:transparent; }

  /* Desktop/tablet default */
  #fx{
    display:block;
    width:100%;
    height:var(--height);
    pointer-events:none;
  }

  /* ðŸš« Force EXACT 400Ã—800 on mobile */
  @media (max-width:768px){
    #fx{
      width:400px !important;
      height:800px !important;
      margin:0 auto !important;
      display:block !important;
      max-width:none !important;
      max-height:none !important;
      min-width:400px !important;
      min-height:800px !important;
      flex:none !important;
    }
  }
</style>
</head>
<body>
<canvas id="fx" width="400" height="800"></canvas>

<script>
const canvas = document.getElementById('fx');
const gl = canvas.getContext('webgl', { alpha:true, antialias:true, premultipliedAlpha:true });
if(!gl){ throw new Error('WebGL not supported'); }
const DPR = Math.min(devicePixelRatio||1, 2);

const VSH = `
attribute vec2 p; varying vec2 uv;
void main(){ uv = p*0.5+0.5; gl_Position = vec4(p,0.,1.); }
`;
const FSH = `
precision highp float; varying vec2 uv;
uniform vec2 uRes; uniform float uT, uSpeed, uSwirl, uDetail, uSoft, uAlpha;
uniform vec3 uA, uB;
/* 3D simplex + fbm */
vec3 mod289(vec3 x){return x-floor(x*(1./289.))*289.;}
vec4 mod289(vec4 x){return x-floor(x*(1./289.))*289.;}
vec4 permute(vec4 x){return mod289(((x*34.)+1.)*x);}
vec4 taylorInvSqrt(vec4 r){return 1.79284291400159-0.85373472095314*r;}
float snoise(vec3 v){
  const vec2 C=vec2(1./6.,1./3.); const vec4 D=vec4(0.,.5,1.,2.);
  vec3 i=floor(v+dot(v,C.yyy));
  vec3 x0=v-i+dot(i,C.xxx);
  vec3 g=step(x0.yzx,x0.xyz), l=1.-g;
  vec3 i1=min(g.xyz,l.zxy), i2=max(g.xyz,l.zxy);
  vec3 x1=x0-i1+C.xxx, x2=x0-i2+2.*C.xxx, x3=x0-1.+3.*C.xxx;
  i=mod289(i);
  vec4 p=permute(permute(permute(i.z+vec4(0.,i1.z,i2.z,1.))+i.y+vec4(0.,i1.y,i2.y,1.))+i.x+vec4(0.,i1.x,i2.x,1.));
  float n_=0.142857142857; vec3 ns=n_*D.wyz-D.xzx;
  vec4 j=p-49.*floor(p*ns.z*ns.z);
  vec4 x_=floor(j*ns.z), y_=floor(j-7.*x_);
  vec4 x=x_*ns.x+ns.yyyy, y=y_*ns.x+ns.yyyy, h=1.-abs(x)-abs(y);
  vec4 b0=vec4(x.xy,y.xy), b1=vec4(x.zw,y.zw);
  vec4 s0=floor(b0)*2.+1., s1=floor(b1)*2.+1., sh=-step(h,vec4(0.));
  vec4 a0=b0.xzyw+s0.xzyw*sh.xxyy, a1=b1.xzyw+s1.xzyw*sh.zzww;
  vec3 p0=vec3(a0.xy,h.x), p1=vec3(a0.zw,h.y), p2=vec3(a1.xy,h.z), p3=vec3(a1.zw,h.w);
  vec4 norm=taylorInvSqrt(vec4(dot(p0,p0),dot(p1,p1),dot(p2,p2),dot(p3,p3)));
  p0*=norm.x; p1*=norm.y; p2*=norm.z; p3*=norm.w;
  vec4 m=max(0.6-vec4(dot(x0,x0),dot(x1,x1),dot(x2,x2),dot(x3,x3)),0.); m*=m;
  return 42.*dot(m*m,vec4(dot(p0,x0),dot(p1,x1),dot(p2,x2),dot(p3,x3)));
}
float fbm(vec3 p){
  float f=0., a=.5;
  for(int i=0;i<5;i++){ f+=a*snoise(p); p=p*2.02+vec3(.3,.6,.2); a*=.5; }
  return f*0.5+0.5;
}
void main(){
  float aspect = uRes.x/uRes.y;
  vec2 suv = vec2(uv.x*aspect, uv.y);

  // Upward drift (from bottom -> up) + gentle internal evolution
  vec3 base = vec3(suv.x*uDetail, (suv.y - uT*uSpeed)*uDetail, uT*uSwirl);

  // Domain-warped fbm for silky smoke
  float w1 = fbm(base);
  float w2 = fbm(base + vec3(0.7,0.5,0.3));
  float n  = fbm(base + vec3(w1-0.5, w2-0.5, 0.0)*0.8);

  // Softer fade so it rises taller
  float density = smoothstep(0.35, 0.90, n);
  float envelope = pow(1.0 - uv.y, uSoft);          // lower uSoft = taller
  float a = clamp(density * envelope * uAlpha, 0.0, 1.0);

  // Light grey smoke + tiny dither
  vec3 col = mix(uB, uA, density*0.95);
  float d = fract(sin(dot(uv*uRes, vec2(12.9898,78.233))) * 43758.5453);
  col += (d-0.5)*0.0035;

  gl_FragColor = vec4(col, a);
}
`;

function compile(t,src){
  const s=gl.createShader(t); gl.shaderSource(s,src); gl.compileShader(s);
  if(!gl.getShaderParameter(s,gl.COMPILE_STATUS)) throw new Error(gl.getShaderInfoLog(s));
  return s;
}
const prog=gl.createProgram();
gl.attachShader(prog, compile(gl.VERTEX_SHADER, VSH));
gl.attachShader(prog, compile(gl.FRAGMENT_SHADER, FSH));
gl.linkProgram(prog);
if(!gl.getProgramParameter(prog, gl.LINK_STATUS)) throw new Error(gl.getProgramInfoLog(prog));
gl.useProgram(prog);

const buf=gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buf);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, 1,1]), gl.STATIC_DRAW);
const loc=gl.getAttribLocation(prog,'p'); gl.enableVertexAttribArray(loc);
gl.vertexAttribPointer(loc,2,gl.FLOAT,false,0,0);

const Ures=gl.getUniformLocation(prog,'uRes');
const Ut=gl.getUniformLocation(prog,'uT');
const Uspeed=gl.getUniformLocation(prog,'uSpeed');
const Uswirl=gl.getUniformLocation(prog,'uSwirl');
const Udet=gl.getUniformLocation(prog,'uDetail');
const Usoft=gl.getUniformLocation(prog,'uSoft');
const Ualpha=gl.getUniformLocation(prog,'uAlpha');
const UA=gl.getUniformLocation(prog,'uA');
const UB=gl.getUniformLocation(prog,'uB');

const css=getComputedStyle(document.documentElement);
const num=(name,def)=>{ const v=parseFloat(css.getPropertyValue(name)); return Number.isFinite(v)?v:def; };
const parseColor = name => {
  let c = css.getPropertyValue(name).trim() || '#B1B5C0';
  const ctx = document.createElement('canvas').getContext('2d'); ctx.fillStyle=c;
  const m = ctx.fillStyle.match(/\d+(\.\d+)?/g).map(Number);
  return new Float32Array([m[0]/255, m[1]/255, m[2]/255]);
};

gl.uniform1f(Uspeed, num('--speed',0.045));
gl.uniform1f(Uswirl, num('--swirl',0.10));
gl.uniform1f(Udet,   num('--detail',1.5));
gl.uniform1f(Usoft,  num('--soft',1.0));   // â†“ taller
gl.uniform1f(Ualpha, num('--alpha',0.96)); // â†‘ stronger
gl.uniform3fv(UA, parseColor('--colorA'));
gl.uniform3fv(UB, parseColor('--colorB'));

const mqMobile = matchMedia('(max-width:768px)');

/* Exact 400Ã—800 on mobile, otherwise responsive */
function sizeToTarget(){
  if (mqMobile.matches){
    canvas.width  = Math.floor(400 * DPR);
    canvas.height = Math.floor(800 * DPR);
  } else {
    const w = canvas.clientWidth, h = canvas.clientHeight;
    canvas.width  = Math.max(2, Math.floor(w * DPR));
    canvas.height = Math.max(2, Math.floor(h * DPR));
  }
  gl.viewport(0,0,canvas.width,canvas.height);
  gl.uniform2f(Ures, canvas.width, canvas.height);
}

new ResizeObserver(sizeToTarget).observe(canvas);
mqMobile.addEventListener?.('change', sizeToTarget);

let t0=performance.now();
function draw(t){ gl.uniform1f(Ut,(t-t0)/1000); gl.drawArrays(gl.TRIANGLE_STRIP,0,4); requestAnimationFrame(draw); }
sizeToTarget(); requestAnimationFrame(draw);
</script>
</body>
</html>
